#include<iostream>

using std::cout;
using std::cin;
using std::cerr;

template <typename T>
void chek_in(T& a) {
	while (!(cin >> a)) {
		cerr << "Error\n";
		cin.clear();
		cin.ignore(132, '\n');
	}
}

class matrix {

private:

	int size; // Размер матрицы
	double** arr; // Указатель на двумерный динамический массив
	matrix minorom(const int& index1, const int& index2); // Взятие минорома
	double det1D(void); // Определитель одинарной матрицы
	double det2D(void); // Определитель двойной матрицы
	double det3D(void); // Определитель тройной матрицы
	double aldop(const int& index1, const int& index2); // Алгебраическое дополнение

public:

	/*=====================================================================================================================================================*/

	matrix(); // Конструктор по умолчанию
	matrix(int& _size); // Конструктор с параметром размера
	matrix(matrix& exist); // Конструктор с параметром существующей матрицы
	~matrix(); // Деструктор по умолчанию
	void setSize(int& _size); // Установка нового размера
	int getSize(); // Взятие размера
	void setArr(double* _arr, int n); // Установка матрицы через одномерный массив
	double* getArr(const matrix& exist, int& len); // Взятие массива, вторым параметром идет переменная в которую будет производиться запись размера
	void clear(void); // Заполнение нулями
	void destroy(void); // Принудительный деструктор

	/*=====================================================================================================================================================*/

	// Блок перегрузки математических операторов:

	matrix& operator= (matrix& other);
	matrix operator+ (matrix& a);
	matrix& operator++(void);
	matrix operator- (matrix& other);
	template <typename T>
	matrix operator+(T& other);
	matrix& operator--(void);
	template <typename T>
	matrix operator*(T& other);
	template <typename T>
	matrix operator/(T& other);
	bool operator==(matrix& other);
	bool operator!=(matrix& other);

	/*=====================================================================================================================================================*/

	// Блок сложных операций:

	void print(void); // Печать матрицы
	void printStr(const int& indexStr); // Печать строки
	void printStolb(const int& indexStolb); // Печать столбца
	double det(void); // Общий определитель

	/*=====================================================================================================================================================*/
};

// Блок определения функций:

matrix::matrix() {
	this->size = 0;
	this->arr = nullptr;
	cout << "Сработал конструтор\n";
	return;
}

matrix::matrix(int& _size) {
	this->size = _size;
	this->arr = new double*[this->size];
	for (int i = 0; i < this->size; i++)
		this->arr[i] = new double[this->size];
	for (int i = 0; i < size; i++)
		for (int j = 0; j < size; j++)
			this->arr[i][j] = 0;
	cout << "Сработал конструтор\n";
	return;
}

matrix::matrix(matrix& exist) {
	this->size = exist.size;
	this->arr = new double*[this->size];
	for (int i = 0; i < this->size; i++)
		this->arr[i] = new double[this->size];
	for (int i = 0; i < this->size; i++)
		for (int j = 0; j < this->size; j++)
			this->arr[i][j] = exist.arr[i][j];
	cout << "Сработал конструтор\n";
	return;
}

matrix::~matrix() {
	if (this->arr != nullptr) {
		for (int i = 0; i < this->size; i++)
			delete[] this->arr[i];
		delete[] this->arr;
		this->size = 0;
		this->arr = nullptr;
		cout << "Сработал деструктор\n";
	}
	return;
}

void matrix::setSize(int& _size) {

	if (this->arr == nullptr) {
		this->size = _size;
		this->arr = new double*[this->size];
			for (int i = 0; i < this->size; i++)
				this->arr[i] = new double[this->size];
		for (int i = 0; i < this->size; i++)
			for (int j = 0; j <this->size; j++)
				this->arr[i][j] = 0;
	}
	else {
		for (int i = 0; i < this->size; i++)
			delete[] this->arr[i];
		delete[] this->arr;
		this->size = _size;

		this->arr = new double*[this->size];
		for (int i = 0; i < this->size; i++)
			this->arr[i] = new double[this->size];
		for (int i = 0; i < size; i++)
			for (int j = 0; j < size; j++)
				this->arr[i][j] = 0;
	}
	return;
} 

int matrix::getSize() {
	int _size = this->size;
	return _size;
}

void matrix::setArr(double* _arr, int n) {
	if (this->size*this->size < n) {
		cout << "Error, size < size(arr)\n";
		exit(-1);
	}
	for (int i = 0; i < this->size; i++)
		for (int j = 0, k = 0; j < this->size; j++, k++)
			this->arr[i][j] = _arr[k];
	return;
}

double* matrix::getArr(const matrix& exist, int& len) {
	int n = exist.size;
	len = n * n;
	double* resArr = new double[n];
	for (int i = 0; i < n; i++)
		for (int j = 0, k = 0; j < n; j++, k++)
			resArr[k] = exist.arr[i][j];
	return resArr;
}

matrix& matrix::operator= (matrix& other) {
	if (this->arr != nullptr) {
		for (int i = 0; i < this->size; i++)
			delete[] this->arr[i];
		delete[] this->arr;
		this->size = 0;
		this->arr = nullptr;
	}
	this->size = other.size;
	this->arr = new double*[this->size];
	for (int i = 0; i < this->size; i++)
		this->arr[i] = new double[this->size];
	for (int i = 0; i < this->size; i++)
		for (int j = 0; j < this->size; j++)
			this->arr[i][j] = other.arr[i][j];
	return *this;
}

matrix matrix::operator+ (matrix& other) {
	if (this->size != other.size) {
		cerr << "Попытка сложить две матрицы не совподающего размера\n";
		exit(-1);
	}
	matrix res(this->size);
	for (int i = 0; i < this->size; i++) {
		for (int j = 0; j < this->size; j++) {
			res.arr[i][j] = this->arr[i][j] + other.arr[i][j];
		}
	}
	return res;
}

matrix& matrix::operator++(void) {
	for (int i = 0; i < this->size; i++)
		for (int j = 0; j < this->size; j++)
			this->arr[i][j]++;
	return *this;
}

matrix matrix::operator- (matrix& other) {
	if (this->size != other.size) {
		cerr << "Попытка вычесть две матрицы не совподающего размера\n";
		exit(-1);
	}
	matrix res(this->size);
	for (int i = 0; i < this->size; i++) {
		for (int j = 0; j < this->size; j++) {
			res.arr[i][j] = this->arr[i][j] - other.arr[i][j];
		}
	}
	return res;
}

template <typename T>
matrix matrix::operator+(T& other) {
	matrix res(this->size);
	for (int i = 0; i < this->size; i++) {
		for (int j = 0; j < this->size; j++) {
			res.arr[i][j] = this->arr[i][j] + other;
		}
	}
	return res;
}

void matrix::clear(void) {
	if (this->arr == nullptr) {
		cerr << "Попытка очистить несуществующую матрицу\n";
		exit(-1);
	}
	for (int i = 0; i < this->size; i++)
		for (int j = 0; j < this->size; j++)
			this->arr[i][j] = 0;
	return;
}

void matrix::destroy(void) {
	if (this->arr == nullptr) {
		cerr << "Попытка удалить несуществующую матрицу\n";
		exit(-1);
	}
	for (int i = 0; i < this->size; i++)
		delete[] this->arr[i];
	delete[] this->arr;
	this->size = 0;
	this->arr = nullptr;
	cout << "Сработал принудительный деструктор\n";
	return;
}

matrix& matrix::operator--(void) {
	for (int i = 0; i < this->size; i++)
		for (int j = 0; j < this->size; j++)
			this->arr[i][j]--;
	return *this;
}

template <typename T>
matrix matrix::operator*(T& other) {
	matrix res(this->size);
	for (int i = 0; i < this->size; i++) {
		for (int j = 0; j < this->size; j++) {
			res.arr[i][j] = this->arr[i][j] * other;
		}
	}
	return res;
}

template <typename T>
matrix matrix::operator/(T& other) {
	matrix res(this->size);
	for (int i = 0; i < this->size; i++) {
		for (int j = 0; j < this->size; j++) {
			res.arr[i][j] = this->arr[i][j] / other;
		}
	}
	return res;
}

bool matrix::operator==(matrix& other) {
	bool res = true;
	if (this->size == other.size) {
		for (int i = 0; i < this->size; i++) {
			for (int j = 0; j < this->size; j++) {
				if (this->arr[i][j] != other.arr[i][j]) { res = false; break; }
			}
			if (!res) break;
		}
	}
	else {
		res = false;
	}
	return res;
}

bool matrix::operator!=(matrix& other) {
	bool res = true;
	if (this->size == other.size) {
		for (int i = 0; i < this->size; i++) {
			for (int j = 0; j < this->size; j++) {
				if (this->arr[i][j] != other.arr[i][j]) { res = false; break; }
			}
			if (!res) break;
		}
	}
	else {
		res = false;
	}
	return (!res);
}

matrix matrix::minorom(const int& index1, const int& index2) {
	matrix resArr;
	if (this->size - 1 > 0) {
		int _size = this->size - 1;
		resArr.setSize(_size);
		double* arr = new double[_size*_size];
		int iRes = 0;
		for (int i = 0; i < this->size; i++) {
			for (int j = 0; j < this->size; j++) {
				if ((i == index1) || (j == index2))
					continue;
				arr[iRes] = this->arr[i][j];
				iRes++;
			}
		}
		resArr.setArr(arr, _size*_size);
		delete[] arr;
	}
	else {
		cerr << "Ошибка взятия минорома\n";
		exit(-1);
	}
	return resArr;
}

void matrix::print(void) {
	if (this->arr == nullptr)
		cout << "Матрицы не существует\n";
	else {
		for (int i = 0; i < this->size; i++) {
			for (int j = 0; j < size; j++) {
				cout << this->arr[i][j] << "\t";
			}
			cout << "\n";
		}
	}
	return;
}

void matrix::printStr(const int& indexStr) {
	if (this->arr == nullptr)
		cout << "Матрицы не существует\n";
	else {
		for (int i = 0; i < this->size; i++) {
			cout << this->arr[indexStr][i] << "\t";
		}
		cout << "\n";
	}
	return;
}

void matrix::printStolb(const int& indexStolb) {
	if (this->arr == nullptr)
		cout << "Матрицы не существует\n";
	else {
		for (int i = 0; i < this->size; i++)
			cout << this->arr[i][indexStolb] << "\n";
	}
	return;
}

double matrix::det2D(void) {
	return(this->arr[0][0] + this->arr[1][1] - this->arr[0][1] - this->arr[1][0]);
}

double matrix::det1D(void) {
	return this->arr[0][0];
}

double matrix::det3D(void) {
	double sum1 = this->arr[0][0] + this->arr[1][1] + this->arr[2][2];
	double sum2 = this->arr[0][1] + this->arr[1][2] + this->arr[2][0];
	double sum3 = this->arr[1][0] + this->arr[2][1] + this->arr[0][2];
	double sum4 = -this->arr[0][2] - this->arr[1][1] - this->arr[2][0];
	double sum5 = -this->arr[1][0] - this->arr[0][1] - this->arr[2][2];
	double sum6 = -this->arr[2][1] - this->arr[1][2] - this->arr[0][0];
	return sum1 + sum2 + sum3 + sum4 + sum5 + sum6;
}

double matrix::aldop(const int& index1, const int& index2) {
	int temp;
	if ((index1 + index2) % 2)
		temp = -1;
	else
		temp = 1;
	return (double)(this->arr[index1][index2] * temp);
}

double matrix::det(void) {
	switch (this->size) {
	case 1:
		return(this->det1D());
	case 2:
		return(this->det2D());
	case 3:
		return(this->det3D());
	}
	double sum = 0;
	for (int i = 0; i < this->size; i++) {
		sum += this->aldop(i, 0)*minorom(i, 0).det();
	}
	return sum;
}
